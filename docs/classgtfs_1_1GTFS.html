<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Transit Network Model: gtfs::GTFS Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Transit Network Model
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegtfs.html">gtfs</a></li><li class="navelem"><a class="el" href="classgtfs_1_1GTFS.html">GTFS</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgtfs_1_1GTFS-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gtfs::GTFS Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="gtfs_8h_source.html">gtfs.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe065541610fe5d9673bc4befd0bcf94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#abe065541610fe5d9673bc4befd0bcf94">GTFS</a> (std::string &amp;dbname, std::string &amp;v)</td></tr>
<tr class="separator:abe065541610fe5d9673bc4befd0bcf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40054a8e935d46bb372538a4b3d8e262"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40054a8e935d46bb372538a4b3d8e262"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_dbname</b> (void)</td></tr>
<tr class="separator:a40054a8e935d46bb372538a4b3d8e262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860f598fdd39e238cae2a446826ede7b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Stop.html">Stop</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#a860f598fdd39e238cae2a446826ede7b">get_stop</a> (std::string &amp;s) const </td></tr>
<tr class="separator:a860f598fdd39e238cae2a446826ede7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cc16f11c4e0db3d2003e591e4d79a5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Intersection.html">Intersection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#ac5cc16f11c4e0db3d2003e591e4d79a5">get_intersection</a> (unsigned int i) const </td></tr>
<tr class="separator:ac5cc16f11c4e0db3d2003e591e4d79a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa171ddb8e40baa60375a0d1f171941e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Segment.html">Segment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#aaa171ddb8e40baa60375a0d1f171941e">get_segment</a> (unsigned long s) const </td></tr>
<tr class="separator:aaa171ddb8e40baa60375a0d1f171941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeffca4aa9bed086fe99166f1e9ebe7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Trip.html">Trip</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#a4aeffca4aa9bed086fe99166f1e9ebe7">get_trip</a> (std::string &amp;t)</td></tr>
<tr class="separator:a4aeffca4aa9bed086fe99166f1e9ebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2363b2b77498cf0096f81b2d848e17b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Route.html">Route</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#ae2363b2b77498cf0096f81b2d848e17b">get_route</a> (std::string &amp;r)</td></tr>
<tr class="separator:ae2363b2b77498cf0096f81b2d848e17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af370a41d67e8978da1c6243279c70919"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Shape.html">Shape</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#af370a41d67e8978da1c6243279c70919">get_shape</a> (std::string &amp;s)</td></tr>
<tr class="separator:af370a41d67e8978da1c6243279c70919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a81248120e12d5a5d52a92821b827e"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Stop.html">Stop</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#a33a81248120e12d5a5d52a92821b827e">get_stops</a> (void)</td></tr>
<tr class="separator:a33a81248120e12d5a5d52a92821b827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132b9a970f4ff1c04fd30a69fc1815a0"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; unsigned long, std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Intersection.html">Intersection</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#a132b9a970f4ff1c04fd30a69fc1815a0">get_intersections</a> (void)</td></tr>
<tr class="separator:a132b9a970f4ff1c04fd30a69fc1815a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae124db38217498c5e1090447ccf11953"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; unsigned long, std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Segment.html">Segment</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#ae124db38217498c5e1090447ccf11953">get_segments</a> (void)</td></tr>
<tr class="separator:ae124db38217498c5e1090447ccf11953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad526fc627fe1ce81b8a669f6187be0c0"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Trip.html">Trip</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#ad526fc627fe1ce81b8a669f6187be0c0">get_trips</a> (void)</td></tr>
<tr class="separator:ad526fc627fe1ce81b8a669f6187be0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6a88c15cdf8bf788e41c81a14ecc76"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Route.html">Route</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#aef6a88c15cdf8bf788e41c81a14ecc76">get_routes</a> (void)</td></tr>
<tr class="separator:aef6a88c15cdf8bf788e41c81a14ecc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ada6a3f02e3ee9b6a723a6c6fc50af"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Shape.html">Shape</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtfs_1_1GTFS.html#a91ada6a3f02e3ee9b6a723a6c6fc50af">get_shapes</a> (void)</td></tr>
<tr class="separator:a91ada6a3f02e3ee9b6a723a6c6fc50af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classgtfs_1_1GTFS.html">GTFS</a> Schedule Information class</p>
<p>This class is used to provide convenient access to the static <a class="el" href="classgtfs_1_1GTFS.html">GTFS</a> data stored in memory. It contains the individual objects such as trips, routes, etc. all initializaed as interrelated classes. Initialized once, an object of this class can be passed by reference to any functions/classes that require access to the static <a class="el" href="classgtfs_1_1GTFS.html">GTFS</a> data.</p>
<p>Those functions that need access are expected to know what it is they need. For example a vehicle needs it's trip, </p><div class="fragment"><div class="line"><span class="keyword">auto</span> trp = <a class="code" href="namespacegtfs.html">gtfs</a>.trip (TRIP_ID); <span class="comment">// A pointer to a trip object</span></div><div class="line">trp-&gt;get_route ()-&gt;get_short_name ();</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abe065541610fe5d9673bc4befd0bcf94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gtfs::GTFS::GTFS </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor for the main <a class="el" href="classgtfs_1_1GTFS.html">GTFS</a> object.</p>
<p>This contains the actual values of all the <a class="el" href="classgtfs_1_1GTFS.html">GTFS</a> static data, so it can be accessed throughout the program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>the name of the database to pull the <a class="el" href="classgtfs_1_1GTFS.html">GTFS</a> data from </td></tr>
    <tr><td class="paramname">v</td><td>a version string to limit how much data is loaded </td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">    if (false) {
        std::string qry;
</pre><p>Stops sqlite3_stmt* stmt_stops; qry = "SELECT stop_id, lat, lng FROM stops"; if (sqlite3_prepare_v2 (db, qry.c_str (), -1, &amp;stmt_stops, 0) != SQLITE_OK) { std::cerr &lt;&lt; " * Can't prepare query " &lt;&lt; qry &lt;&lt; "\n"; throw std::runtime_error ("Cannot prepare query."); }; std::clog &lt;&lt; " * [prepared] " &lt;&lt; qry &lt;&lt; "\n"; while (sqlite3_step (stmt_stops) == SQLITE_ROW) { std::string stop_id = (char*)sqlite3_column_text (stmt_stops, 0); <a class="el" href="classgps_1_1Coord.html">gps::Coord</a> pos (sqlite3_column_double (stmt_stops, 1), sqlite3_column_double (stmt_stops, 2)); std::shared_ptr&lt;gtfs::Stop&gt; stop (new <a class="el" href="classgtfs_1_1Stop.html">gtfs::Stop(stop_id, pos)</a>); stops.emplace (stop_id, stop); } sqlite3_finalize (stmt_stops);</p>
<p>N segments: sqlite3_stmt* stmt_n; int Nseg = 0; std::string qwhere; qwhere = " WHERE segment_id IN (SELECT segment_id FROM shapes WHERE shape_id LIKE '%_v" + v + "')"; qwhere = " WHERE segment_id IN (SELECT segment_id FROM shapes WHERE shape_id IN (" "SELECT shape_id FROM routes WHERE shape_id LIKE '%_v" + v + "' AND route_short_name IN ('274','277','258','NEX','881') ) )"; if (sqlite3_prepare_v2 (db, ("SELECT count(segment_id) FROM segments" + qwhere).c_str (), -1, &amp;stmt_n, 0) == SQLITE_OK &amp;&amp; sqlite3_step (stmt_n) == SQLITE_ROW) { Nseg = sqlite3_column_int (stmt_n, 0); } sqlite3_finalize (stmt_n);</p>
<p>Load all gtfs <code>segments</code> sqlite3_stmt* stmt_segs; qry = "SELECT segment_id, start_id, end_id, length FROM segments" + qwhere;</p>
<p>if (sqlite3_prepare_v2 (db, qry.c_str (), -1, &amp;stmt_segs, 0) != SQLITE_OK) { std::cerr &lt;&lt; " * Can't prepare query " &lt;&lt; qry &lt;&lt; ": " &lt;&lt; sqlite3_errmsg (db) &lt;&lt; "\n"; throw std::runtime_error ("Cannot prepare query."); } std::clog &lt;&lt; " * [prepared] " &lt;&lt; qry &lt;&lt; "\n"; PREPARE query for segment path sqlite3_stmt* stmt_path; if (sqlite3_prepare_v2 (db, "SELECT lat, lng, seg_dist_traveled FROM segment_pt WHERE segment_id=?1 ORDER BY seg_pt_sequence", -1, &amp;stmt_path, 0) != SQLITE_OK) { throw std::runtime_error ("Cannot prepare SELECT PATH query."); } int i = 0; while (sqlite3_step (stmt_segs) == SQLITE_ROW) { unsigned long segment_id = sqlite3_column_int (stmt_segs, 0); std::shared_ptr&lt;Intersection&gt; start_at, end_at; if (sqlite3_column_type (stmt_segs, 1) != SQLITE_NULL) { unsigned long start_id = sqlite3_column_int (stmt_segs, 1); get intersection object </p><pre class="fragment">            }
            if (sqlite3_column_type (stmt_segs, 2) != SQLITE_NULL) {
                unsigned long end_id = sqlite3_column_int (stmt_segs, 2);
</pre><p> get intersection object </p><pre class="fragment">            }
            double length = sqlite3_column_double (stmt_segs, 3);
</pre><p> Get the segment's PATH: if (sqlite3_bind_int64 (stmt_path, 1, segment_id) != SQLITE_OK) { throw std::runtime_error ("Cannot fetch segment path."); } std::vector&lt;ShapePt&gt; path; while (sqlite3_step (stmt_path) == SQLITE_ROW) { path.emplace_back (<a class="el" href="classgps_1_1Coord.html">gps::Coord</a> (sqlite3_column_double (stmt_path, 0), sqlite3_column_double (stmt_path, 1)), sqlite3_column_double (stmt_path, 2)); } sqlite3_reset (stmt_path); std::shared_ptr&lt;Segment&gt; segment (new <a class="el" href="classgtfs_1_1Segment.html">Segment</a> (segment_id, start_at, end_at, path, length)); segments.emplace (segment_id, segment);</p>
<p>printf(" * Loading shapes: %*d%%\r", 3, 100 * (++i) / Nseg); std::cout.flush (); } sqlite3_finalize (stmt_segs); sqlite3_finalize (stmt_path);</p>
<p>Load all gtfs <code>shapes</code> sqlite3_stmt* stmt_shapes; qry = "SELECT shape_id, leg, segment_id, shape_dist_traveled FROM shapes"; if (version_ != "") qry += " WHERE shape_id LIKE '%_v" + version_ + "'"; qry += " ORDER BY shape_id, leg"; if (sqlite3_prepare_v2 (db, qry.c_str (), -1, &amp;stmt_shapes, 0) != SQLITE_OK) { std::cerr &lt;&lt; " * Can't prepare query " &lt;&lt; qry &lt;&lt; "\n"; throw std::runtime_error ("Cannot prepare query."); } std::clog &lt;&lt; " * [prepared] " &lt;&lt; qry &lt;&lt; "\n"; while (sqlite3_step (stmt_shapes) == SQLITE_ROW) { std::string shape_id = (char*)sqlite3_column_text (stmt_shapes, 0); std::shared_ptr&lt;Shape&gt; shape (get_shape (shape_id)); Does that shape already exist? if (shape == nullptr) { Nope - create a new one std::shared_ptr&lt;Shape&gt; sh (new Shape(shape_id)); shape = sh; shapes.emplace (shape_id, shape); } Find segment: std::shared_ptr&lt;Segment&gt; segment = get_segment (sqlite3_column_int (stmt_shapes, 2)); if (segment != nullptr) { shape-&gt;add_segment (segment, sqlite3_column_double (stmt_shapes, 3)); } } sqlite3_finalize (stmt_shapes);</p>
<p>Load all gtfs <code>routes</code> sqlite3_stmt* stmt_routes; qry = "SELECT route_id, route_short_name, route_long_name, shape_id FROM routes"; if (version_ != "") qry += " WHERE route_id LIKE '%_v" + version_ + "'"; if (sqlite3_prepare_v2 (db, qry.c_str (), -1, &amp;stmt_routes, 0) != SQLITE_OK) { std::cerr &lt;&lt; " * Can't prepare query " &lt;&lt; qry &lt;&lt; "\n"; throw std::runtime_error ("Cannot prepare query."); } std::clog &lt;&lt; " * [prepared] " &lt;&lt; qry &lt;&lt; "\n"; while (sqlite3_step (stmt_routes) == SQLITE_ROW) { std::string route_id = (char*)sqlite3_column_text (stmt_routes, 0); std::string short_name = (char*)sqlite3_column_text (stmt_routes, 1); std::string long_name = (char*)sqlite3_column_text (stmt_routes, 2); std::string shape_id = (char*)sqlite3_column_text (stmt_routes, 3); std::shared_ptr&lt;Shape&gt; shape (get_shape (shape_id)); std::shared_ptr&lt;gtfs::Route&gt; route (new <a class="el" href="classgtfs_1_1Route.html">gtfs::Route(route_id, short_name, long_name, shape)</a>); routes.emplace (route_id, route); } sqlite3_finalize (stmt_routes);</p>
<p>n TRIPS int Ntrip = 0; qwhere = " WHERE segment_id IN (SELECT segment_id FROM shapes WHERE shape_id LIKE '%_v" + v + "')"; qwhere = " WHERE route_id IN (SELECT route_id FROM routes WHERE route_id LIKE '%_v"</p><ul>
<li>v + "' AND route_short_name IN ('274','277','258','NEX','881') )"; if (sqlite3_prepare_v2 (db, ("SELECT count(trip_id) FROM trips" + qwhere).c_str (), -1, &amp;stmt_n, 0) == SQLITE_OK &amp;&amp; sqlite3_step (stmt_n) == SQLITE_ROW) { Ntrip = sqlite3_column_int (stmt_n, 0); } sqlite3_finalize (stmt_n);</li>
</ul>
<p>Load all gtfs <code>trips</code> sqlite3_stmt* stmt_trips; sqlite3_stmt* stmt_stoptimes; qry = "SELECT trip_id, route_id FROM trips" + qwhere;</p>
<p>if (sqlite3_prepare_v2 (db, qry.c_str (), -1, &amp;stmt_trips, 0) != SQLITE_OK) { std::cerr &lt;&lt; " * Can't prepare query " &lt;&lt; qry &lt;&lt; "\n"; throw std::runtime_error ("Cannot prepare query."); } std::cout &lt;&lt; " * [prepared] " &lt;&lt; qry &lt;&lt; "\n"; std::string qry_st ("SELECT stop_id, arrival_time, departure_time, shape_dist_traveled FROM stop_times WHERE trip_id=$1 ORDER BY stop_sequence"); if (sqlite3_prepare_v2 (db, qry_st.c_str (), -1, &amp;stmt_stoptimes, 0) != SQLITE_OK) { std::cerr &lt;&lt; " * Can't prepare query " &lt;&lt; qry_st &lt;&lt; "\n"; throw std::runtime_error ("Cannot prepare query."); } std::clog &lt;&lt; " * [prepared] " &lt;&lt; qry_st &lt;&lt; "\n";</p>
<p>int ti=0; std::cout &lt;&lt; "\n   - " &lt;&lt; Ntrip &lt;&lt; " trips to load ...\n"; while (sqlite3_step (stmt_trips) == SQLITE_ROW) { ti++; printf(" * Loading trips: %*d%%\r", 3, 100 * (ti) / Ntrip); std::cout.flush ();</p>
<p>Load that trip into memory: [id, (route)] std::string trip_id = (char*)sqlite3_column_text (stmt_trips, 0); std::string route_id = (char*)sqlite3_column_text (stmt_trips, 1); auto route = get_route (route_id); if (!route) continue; std::shared_ptr&lt;gtfs::Trip&gt; trip (new <a class="el" href="classgtfs_1_1Trip.html">gtfs::Trip(trip_id, route)</a>); route-&gt;add_trip (trip);</p>
<p>Load trip stop times if (sqlite3_bind_text (stmt_stoptimes, 1, trip_id.c_str (), -1, SQLITE_STATIC) == SQLITE_OK) { std::vector&lt;StopTime&gt; stoptimes; std::vector&lt;double&gt; distances; while (sqlite3_step (stmt_stoptimes) == SQLITE_ROW) { Take stop_time append to vector std::string stop_id = (char*)sqlite3_column_text (stmt_stoptimes, 0); auto stop = get_stop (stop_id); if (!stop) break; // missing any stops, don't include any std::string arr = (char*)sqlite3_column_text (stmt_stoptimes, 1); std::string dep = (char*)sqlite3_column_text (stmt_stoptimes, 2); stoptimes.emplace_back (stop, arr, dep); distances.emplace_back (sqlite3_column_double (stmt_stoptimes, 3)); } sqlite3_reset (stmt_stoptimes);</p>
<p>trip-&gt;add_stoptimes (stoptimes);</p>
<p>If route doesn't have stops already, add them now: if (route-&gt;get_stops ().size () == 0) { std::vector&lt;RouteStop&gt; stops; stops.reserve (trip-&gt;get_stoptimes ().size ()); int si = 0; for (auto&amp; st: trip-&gt;get_stoptimes ()) { if (distances.size () == trip-&gt;get_stoptimes ().size ()) { stops.emplace_back (st.stop, distances[si]); si++; } else { stops.emplace_back (st.stop, 0); } } route-&gt;add_stops (stops); } } else { std::cerr &lt;&lt; "\n     x Error binding trip ID to stoptimes query "; continue; }</p>
<p>And save the trip away trips.emplace (trip_id, trip); } sqlite3_finalize (stmt_stoptimes); sqlite3_finalize (stmt_trips); std::clog &lt;&lt; "\n";</p>
<p>sqlite3_close (db); }</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac5cc16f11c4e0db3d2003e591e4d79a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Intersection.html">Intersection</a> &gt; gtfs::GTFS::get_intersection </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load an <a class="el" href="classgtfs_1_1Intersection.html">Intersection</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the ID of the intersection we want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classgtfs_1_1Intersection.html">Intersection</a> object, or null pointer if it wasn't found </dd></dl>

</div>
</div>
<a class="anchor" id="a132b9a970f4ff1c04fd30a69fc1815a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;unsigned long, std::shared_ptr&lt;<a class="el" href="classgtfs_1_1Intersection.html">Intersection</a>&gt; &gt; gtfs::GTFS::get_intersections </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an unordered map of <a class="el" href="classgtfs_1_1Intersection.html">Intersection</a> objects </dd></dl>

</div>
</div>
<a class="anchor" id="ae2363b2b77498cf0096f81b2d848e17b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Route.html">Route</a> &gt; gtfs::GTFS::get_route </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a <a class="el" href="classgtfs_1_1Route.html">Route</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the ID of the route we want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classgtfs_1_1Route.html">Route</a> object, or null pointer if it wasn't found </dd></dl>

</div>
</div>
<a class="anchor" id="aef6a88c15cdf8bf788e41c81a14ecc76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, std::shared_ptr&lt;<a class="el" href="classgtfs_1_1Route.html">Route</a>&gt; &gt; gtfs::GTFS::get_routes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an unordered map of <a class="el" href="classgtfs_1_1Route.html">Route</a> objects </dd></dl>

</div>
</div>
<a class="anchor" id="aaa171ddb8e40baa60375a0d1f171941e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Segment.html">Segment</a> &gt; gtfs::GTFS::get_segment </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a <a class="el" href="classgtfs_1_1Segment.html">Segment</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the ID of the segment we want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classgtfs_1_1Segment.html">Segment</a> object, or null pointer if it wasn't found </dd></dl>

</div>
</div>
<a class="anchor" id="ae124db38217498c5e1090447ccf11953"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;unsigned long, std::shared_ptr&lt;<a class="el" href="classgtfs_1_1Segment.html">Segment</a>&gt; &gt; gtfs::GTFS::get_segments </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an unordered map of <a class="el" href="classgtfs_1_1Segment.html">Segment</a> objects </dd></dl>

</div>
</div>
<a class="anchor" id="af370a41d67e8978da1c6243279c70919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Shape.html">Shape</a> &gt; gtfs::GTFS::get_shape </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a <a class="el" href="classgtfs_1_1Shape.html">Shape</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the ID of the shape we want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classgtfs_1_1Shape.html">Shape</a> object, or null pointer if it wasn't found </dd></dl>

</div>
</div>
<a class="anchor" id="a91ada6a3f02e3ee9b6a723a6c6fc50af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, std::shared_ptr&lt;<a class="el" href="classgtfs_1_1Shape.html">Shape</a>&gt; &gt; gtfs::GTFS::get_shapes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an unordered map of <a class="el" href="classgtfs_1_1Shape.html">Shape</a> objects </dd></dl>

</div>
</div>
<a class="anchor" id="a860f598fdd39e238cae2a446826ede7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Stop.html">Stop</a> &gt; gtfs::GTFS::get_stop </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a <a class="el" href="classgtfs_1_1Stop.html">Stop</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the ID of the stop we want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classgtfs_1_1Stop.html">Stop</a> object, or null pointer if it wasn't found </dd></dl>

</div>
</div>
<a class="anchor" id="a33a81248120e12d5a5d52a92821b827e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, std::shared_ptr&lt;<a class="el" href="classgtfs_1_1Stop.html">Stop</a>&gt; &gt; gtfs::GTFS::get_stops </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an unordered map of <a class="el" href="classgtfs_1_1Stop.html">Stop</a> objects </dd></dl>

</div>
</div>
<a class="anchor" id="a4aeffca4aa9bed086fe99166f1e9ebe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classgtfs_1_1Trip.html">Trip</a> &gt; gtfs::GTFS::get_trip </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a <a class="el" href="classgtfs_1_1Trip.html">Trip</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the ID of the trip we want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classgtfs_1_1Trip.html">Trip</a> object, or null pointer if it wasn't found </dd></dl>

</div>
</div>
<a class="anchor" id="ad526fc627fe1ce81b8a669f6187be0c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, std::shared_ptr&lt;<a class="el" href="classgtfs_1_1Trip.html">Trip</a>&gt; &gt; gtfs::GTFS::get_trips </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an unordered map of <a class="el" href="classgtfs_1_1Trip.html">Trip</a> objects </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>gtfs/<a class="el" href="gtfs_8h_source.html">gtfs.h</a></li>
<li>gtfs/gtfs.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
